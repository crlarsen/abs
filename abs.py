import sys
from datetime import datetime

# You're welcome to use this code but please leave my copyright notice and the
# citation directing others to my GitHub repository for this code in place.
#
# Copyright 2024, Chris Larsen

dt = datetime.today().strftime("%m/%d/%Y %I:%M:%S %p")

def usage(msg):
  print(msg, file=sys.stderr)
  print("Usage: %s <number of bits>" % (sys.argv[0]), file=sys.stderr)
  sys.exit(1)

CountNotFound = True

if len(sys.argv) == 1:
  usage("ERROR: No arguments given")
elif len(sys.argv) < 4:
  for arg in sys.argv[1:]:
    try:
      count = int(arg)
      CountNotFound = False
    except ValueError:
      usage("ERROR: Input value is not a valid integer: %s" % (arg))

  if CountNotFound:
    usage("ERROR: Missing count argument")
  elif count <= 0:
    usage("ERROR: Number of bits must be a positive number: %d" % (count))
else:
  usage("ERROR: Too many command line arguments")

zero = []

def zeroG(i, j, gInput):
  if (i != -1) and (i == j):
    return True
  elif gInput in zero:
    return True
  else:
    return False

#Header info
print(
'''
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Copyright: Chris Larsen, 2024
// Engineer: Chris Larsen
//
// Create Date: %s
// Design Name:
// Module Name: abs%d
// Project Name:
// Target Devices:
// Tool Versions:
// Description: Find absolute value of %d-bit Signed Integer
//
//       This module was generated by a Python script written by Chris Larsen.
//       Since this code was machine generated, in general you shouldn't be
//       editing this code by hand.
//
//       If the input value is the most negative value then the module will
//       return the most negative value as its output. This is the overflow
//       condition. To test for this an overflow AND together the most
//       significant bits (that is the sign bits of input and the output)
//       of the input and output values. If the AND is true then there was an
//       overflow.
//
//       If bugs are found in the script I (Chris Larsen) would ask that you
//       send your bug fixes, and or other improvements, back so I can include
//       them in the git repository for the abs.py script.
//
//       The Python script used to generate this code can be downloaded from
//       https://github.com/crlarsen/abs/
//
//       This script was derived from padder.py which can be found at
//       https://github.com/crlarsen/padder. A series of simplications were
//       made using the rules of Boolean algebra to arrive at this version of
//       the script.
//
// Dependencies: None
//
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
//
//////////////////////////////////////////////////////////////////////////////////
'''[1:] % (dt, count, count))

print(
'''
module abs%d(A, S);
  localparam N = %d;
  input [N-1:0] A;
  output [N-1:0] S;
  // All Pi:i values are equal to xorA[i]
  wire [N-1:0] xorA = A ^ {N{A[N-1]}};
  // G[i] is an alias for Gi:i
  wire \G-1:-1 = A[N-1];
'''[1:] % (count, count))

#Header info

# Compute the next node in the net.
def node(i, j, l, r):
  if i == j:
    p1Input = "xorA[%d]" % (i)
  else:
    p1Input = "\\P%d:%d " % (i, j)
  g1Input = "\\G%d:%d " % (i, j)

  if (l == r):
    p2Input = "xorA[%d]" % (l)
  else:
    p2Input = "\\P%d:%d " % (l, r)
  g2Input = "\\G%d:%d " % (l, r)

  pOutput = "\\P%d:%d " % (i, r)
  gOutput = "\\G%d:%d " % (i, r)

  if r == -1:
    # We don't need to compute \Pi:-1 because it will never be used.
    # This keeps the Verilog compiler from complaining that we have
    # outputs not connected to inputs.
    if zeroG(i, j, g1Input) and zeroG(l, r, g2Input):
      zero.append(gOutput)
    else:
      print("  wire %s;\n" % (gOutput))
      if zeroG(i, j, g1Input):
        print("  assign %s = %s  & %s;\n" % (gOutput, p1Input, g2Input))
      elif zeroG(l, r, g2Input):
        print("  assign %s = %s;\n" % (gOutput, g1Input))
      else:
        print("  assign %s = %s| (%s  & %s);\n" % (gOutput, g1Input, p1Input, g2Input))
  else:
    if zeroG(i, j, g1Input) and zeroG(l, r, g2Input):
      print("  wire %s;\n" % (pOutput))
    else:
      print("  wire %s, %s;\n" % (pOutput, gOutput))
    #print("  PijGij \\%d:%d (%s, %s, %s, %s, %s, %s);" % (i, r, p1Input, p2Input, g1Input, g2Input, pOutput, gOutput))
    print("  assign %s = %s & %s ;" % (pOutput, p1Input, p2Input))
    if zeroG(i, j, g1Input) and zeroG(l, r, g2Input):
      zero.append(gOutput)
      print("")
    else:
      if zeroG(i, j, g1Input):
        print("  assign %s = %s  & %s;\n" % (gOutput, p1Input, g2Input))
      elif zeroG(l, r, g2Input):
        print("  assign %s = %s;\n" % (gOutput, g1Input))
      else:
        print("  assign %s = %s| (%s  & %s);\n" % (gOutput, g1Input, p1Input, g2Input))

masks = []

for i in range(-1, count-1):
  masks.append([i, i]) # Push new node onto stack.

  # Merge and print top 2 stack items as long as the last N bits of i
  # are equal to 2**N - 2.
  m, v = 1, 0 # Start with N = 1
  while (i & m) == v:
    [i, j] = masks.pop()
    [l, r] = masks[-1]
    node(i, j, l, r)
    masks[-1][0] = i # Merge the 2 top nodes.
    m, v = ((m << 1) | 1), ((v << 1) | 2) # N = N + 1

  # Perform the rest of the work needed to compute Gi:-1
  [i, j] = masks[-1]
  for k in range(len(masks)-2, -1, -1):
    [l, r] = masks[k]
    node(i, j, l, r)
    j = r

  # Use Gi:-1 to propagate carry to compute bit i+1 of the sum.
  print("  assign S[%d] = xorA[%d] ^ \\G%d:-1 ;\n" % (i+1, i+1, i));

# End the module
print("endmodule");
